import { COOKIE_NAME } from "@shared/const";
import { getSessionCookieOptions } from "./_core/cookies";
import { systemRouter } from "./_core/systemRouter";
import { publicProcedure, protectedProcedure, router } from "./_core/trpc";
import { z } from "zod";
import { createTask, getUserTasks, updateTaskStatus, createAgentSession, getUserSessions, createBookmark, getUserBookmarks, deleteBookmark } from "./db";
import { executeAgentTask, getAvailableTools } from "./agent";
import { nanoid } from "nanoid";

export const appRouter = router({
  system: systemRouter,
  auth: router({
    me: publicProcedure.query((opts) => opts.ctx.user),
    logout: publicProcedure.mutation(({ ctx }) => {
      const cookieOptions = getSessionCookieOptions(ctx.req);
      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
      return {
        success: true,
      } as const;
    }),
  }),

  // Task management
  tasks: router({
    create: protectedProcedure
      .input(
        z.object({
          title: z.string().min(1),
          description: z.string().optional(),
          taskType: z.string().min(1),
          input: z.record(z.string(), z.unknown()).optional(),
        })
      )
      .mutation(async ({ ctx, input }) => {
        const result = await createTask(
          ctx.user.id,
          input.title,
          input.description || "",
          input.taskType,
          input.input || {}
        );
        return { success: true, taskId: 0 }; // Task created successfully
      }),

    list: protectedProcedure.query(async ({ ctx }) => {
      return await getUserTasks(ctx.user.id);
    }),

    updateStatus: protectedProcedure
      .input(
        z.object({
          taskId: z.number(),
          status: z.enum(["pending", "running", "completed", "failed"]),
          result: z.record(z.string(), z.unknown()).optional(),
          error: z.string().optional(),
        })
      )
      .mutation(async ({ input }) => {
        await updateTaskStatus(input.taskId, input.status as any, input.result, input.error);
        return { success: true };
      }),

    execute: protectedProcedure
      .input(
        z.object({
          taskId: z.number(),
          description: z.string(),
          context: z.record(z.string(), z.unknown()).optional(),
        })
      )
      .mutation(async ({ ctx, input }) => {
        // Create or get agent session
        const sessions = await getUserSessions(ctx.user.id);
        let sessionId = sessions[0]?.id || 1;

        if (!sessions.length) {
          await createAgentSession(ctx.user.id, nanoid());
          // Session ID will be generated by the database
        }

        // Execute the task
        const result = await executeAgentTask(input.taskId, sessionId, input.description, input.context);
        return result;
      }),
  }),

  // Agent management
  agent: router({
    getTools: publicProcedure.query(() => {
      return getAvailableTools();
    }),

    createSession: protectedProcedure.mutation(async ({ ctx }) => {
      const sessionId = nanoid();
      await createAgentSession(ctx.user.id, sessionId);
      return { success: true, sessionId };
    }),

    getSessions: protectedProcedure.query(async ({ ctx }) => {
      return await getUserSessions(ctx.user.id);
    }),
  }),

  // Bookmarks management
  bookmarks: router({
    create: protectedProcedure
      .input(
        z.object({
          title: z.string().min(1),
          url: z.string().url(),
          folder: z.string().optional(),
        })
      )
      .mutation(async ({ ctx, input }) => {
        const result = await createBookmark(ctx.user.id, input.title, input.url, input.folder);
        return { success: true, bookmarkId: 0 }; // Bookmark created successfully
      }),

    list: protectedProcedure.query(async ({ ctx }) => {
      return await getUserBookmarks(ctx.user.id);
    }),

    delete: protectedProcedure
      .input(z.object({ bookmarkId: z.number() }))
      .mutation(async ({ input }) => {
        await deleteBookmark(input.bookmarkId);
        return { success: true };
      }),
  }),
});

export type AppRouter = typeof appRouter;
